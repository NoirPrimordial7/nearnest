rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /* ------------ helpers ------------ */
    function signedIn() { return request.auth != null; }

    // read the user doc once
    function userDoc(uid) {
      return get(/databases/$(database)/documents/users/$(uid));
    }

    function isAdmin() {
      return signedIn()
        && userDoc(request.auth.uid).exists()
        && userDoc(request.auth.uid).data.roles is list
        && userDoc(request.auth.uid).data.roles.hasAny(['admin']);
    }

    function isOwner(ownerId) {
      return signedIn() && ownerId != null && request.auth.uid == ownerId;
    }

    function isMember(members) {
      return signedIn()
        && members != null
        && (request.auth.uid in members || request.auth.uid in members.keys());
    }

    function isVisibleTo(visibleTo) {
      return signedIn()
        && visibleTo != null
        && visibleTo.hasAny([request.auth.uid]);
    }

    // store access â€” read once and reuse
    function storeDoc(storeId) {
      return get(/databases/$(database)/documents/stores/$(storeId));
    }

    function canAccessStore(storeId) {
      let s = storeDoc(storeId);
      return isOwner(s.data.ownerId)
          || isMember(s.data.members)
          || isVisibleTo(s.data.visibleTo);
    }

    /* ------------ users ------------ */
    match /users/{uid} {
      // user can read/write own profile; admins may read everyone
      allow read: if (signedIn() && request.auth.uid == uid) || isAdmin();
      allow write: if signedIn() && request.auth.uid == uid;
    }

    /* ------------ stores ------------ */
    match /stores/{storeId} {

      // READ: owner/member/visible or admin
      allow read: if canAccessStore(storeId) || isAdmin();

      // CREATE: owner must be the caller OR admin can seed/import
      allow create: if signedIn() && (
        request.resource.data.ownerId == request.auth.uid || isAdmin()
      );

      // UPDATE: owner/member or admin
      allow update: if signedIn() && (
        isOwner(resource.data.ownerId) ||
        isMember(resource.data.members) ||
        isAdmin()
      );

      // DELETE: only owner or admin
      allow delete: if signedIn() && (
        isOwner(resource.data.ownerId) || isAdmin()
      );

      /* --- verification docs: stores/{storeId}/documents/{docId} --- */
      match /documents/{docId} {
        allow read: if canAccessStore(storeId) || isAdmin();

        // create: must be accessible; basic field checks; uploader is caller (admin may also upload)
        allow create: if (canAccessStore(storeId) || isAdmin())
          && request.resource.data.path is string
          && request.resource.data.url  is string
          && request.resource.data.kind is string
          && request.resource.data.uploadedBy is string
          && (
              request.resource.data.uploadedBy == request.auth.uid
              || isAdmin()
          );

        // update: owner/uploader/admin; uploadedBy cannot be reassigned unless admin
        allow update: if signedIn() && (
          isOwner(storeDoc(storeId).data.ownerId) ||
          (resource.data.uploadedBy == request.auth.uid &&
           request.resource.data.uploadedBy == resource.data.uploadedBy) ||
          isAdmin()
        );

        // delete: owner, original uploader, or admin
        allow delete: if signedIn() && (
          isOwner(storeDoc(storeId).data.ownerId) ||
          resource.data.uploadedBy == request.auth.uid ||
          isAdmin()
        );
      }

      /* --- other subcollections under a store --- */
      match /{sub=**}/{docId} {
        allow read:  if canAccessStore(storeId) || isAdmin();
        allow write: if signedIn() && (
          isOwner(storeDoc(storeId).data.ownerId) ||
          isMember(storeDoc(storeId).data.members) ||
          isAdmin()
        );
      }
    }

    /* ------------ default deny ------------ */
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
