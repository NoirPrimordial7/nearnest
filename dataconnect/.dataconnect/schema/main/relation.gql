extend type Product {
  """
  ✨ List `StoreProduct` objects in a one-to-many relationship (where `StoreProduct`.`product` is this object).
  """
  storeProducts_on_product(
    """
    Filter condition to narrow down the query results.
    """
    where: StoreProduct_Filter

    """
    Order the query results by specific fields.
    """
    orderBy: [StoreProduct_Order!]

    """
    Number of rows to skip before starting to return the results.
    """
    offset: Int

    """
    Maximum number of rows to return (defaults to 100 rows).
    """
    limit: Int = 100

    """
    Set to true to return distinct results.
    """
    distinct: Boolean = false

    """
    Filter condition to apply to the groups of aggregate queries.
    """
    having: StoreProduct_Having
  ): [StoreProduct!]! @fdc_generated(from: "StoreProduct.product", purpose: QUERY_MULTIPLE_ONE_TO_MANY)
  """
  ✨ List `Store` objects using `StoreProduct` as the join table (a `StoreProduct` object exists where its `product` is this and its `store` is that).
  """
  stores_via_StoreProduct(
    """
    Filter condition to narrow down the query results.
    """
    where: StoreProduct_Filter

    """
    Order the query results by specific fields.
    """
    orderBy: [StoreProduct_Order!]

    """
    Number of rows to skip before starting to return the results.
    """
    offset: Int

    """
    Maximum number of rows to return (defaults to 100 rows).
    """
    limit: Int = 100

    """
    Set to true to return distinct results.
    """
    distinct: Boolean = false

    """
    Filter condition to apply to the groups of aggregate queries.
    """
    having: StoreProduct_Having
  ): [Store!]! @fdc_generated(from: "StoreProduct", purpose: QUERY_MULTIPLE_MANY_TO_MANY)
  """
  Implicit metadata field that cannot be written. It provides extra information about query results.
  """
  _metadata: _Metadata @fdc_generated(from: "Product", purpose: METADATA_FIELD)
  """
  ✨ Count the number of rows in the `Product` table.
  """
  _count: Int! @fdc_generated(from: "Product.", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Product` table where the `category` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  category_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Product.category", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Product` table where the `description` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  description_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Product.description", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Product` table where the `id` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  id_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Product.id", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Product` table where the `name` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  name_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Product.name", purpose: QUERY_COUNT)
}
extend type SearchHistory {
  """
  Implicit metadata field that cannot be written. It provides extra information about query results.
  """
  _metadata: _Metadata @fdc_generated(from: "SearchHistory", purpose: METADATA_FIELD)
  """
  ✨ Count the number of rows in the `SearchHistory` table.
  """
  _count: Int! @fdc_generated(from: "SearchHistory.", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `SearchHistory` table where the `id` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  id_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "SearchHistory.id", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `SearchHistory` table where the `searchQuery` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  searchQuery_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "SearchHistory.searchQuery", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `SearchHistory` table where the `searchedAt` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  searchedAt_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "SearchHistory.searchedAt", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `SearchHistory` table where the `userId` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  userId_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "SearchHistory.userId", purpose: QUERY_COUNT)
  """
  ✨ Minimum of the `searchedAt` field in the `SearchHistory` table.
  """
  searchedAt_min: Timestamp @fdc_generated(from: "SearchHistory.searchedAt", purpose: QUERY_MIN)
  """
  ✨ Maximum of the `searchedAt` field in the `SearchHistory` table.
  """
  searchedAt_max: Timestamp @fdc_generated(from: "SearchHistory.searchedAt", purpose: QUERY_MAX)
}
extend type Store {
  """
  ✨ List `StoreProduct` objects in a one-to-many relationship (where `StoreProduct`.`store` is this object).
  """
  storeProducts_on_store(
    """
    Filter condition to narrow down the query results.
    """
    where: StoreProduct_Filter

    """
    Order the query results by specific fields.
    """
    orderBy: [StoreProduct_Order!]

    """
    Number of rows to skip before starting to return the results.
    """
    offset: Int

    """
    Maximum number of rows to return (defaults to 100 rows).
    """
    limit: Int = 100

    """
    Set to true to return distinct results.
    """
    distinct: Boolean = false

    """
    Filter condition to apply to the groups of aggregate queries.
    """
    having: StoreProduct_Having
  ): [StoreProduct!]! @fdc_generated(from: "StoreProduct.store", purpose: QUERY_MULTIPLE_ONE_TO_MANY)
  """
  ✨ List `Product` objects using `StoreProduct` as the join table (a `StoreProduct` object exists where its `store` is this and its `product` is that).
  """
  products_via_StoreProduct(
    """
    Filter condition to narrow down the query results.
    """
    where: StoreProduct_Filter

    """
    Order the query results by specific fields.
    """
    orderBy: [StoreProduct_Order!]

    """
    Number of rows to skip before starting to return the results.
    """
    offset: Int

    """
    Maximum number of rows to return (defaults to 100 rows).
    """
    limit: Int = 100

    """
    Set to true to return distinct results.
    """
    distinct: Boolean = false

    """
    Filter condition to apply to the groups of aggregate queries.
    """
    having: StoreProduct_Having
  ): [Product!]! @fdc_generated(from: "StoreProduct", purpose: QUERY_MULTIPLE_MANY_TO_MANY)
  """
  Implicit metadata field that cannot be written. It provides extra information about query results.
  """
  _metadata: _Metadata @fdc_generated(from: "Store", purpose: METADATA_FIELD)
  """
  ✨ Count the number of rows in the `Store` table.
  """
  _count: Int! @fdc_generated(from: "Store.", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Store` table where the `address` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  address_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Store.address", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Store` table where the `createdAt` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  createdAt_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Store.createdAt", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Store` table where the `id` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  id_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Store.id", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Store` table where the `latitude` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  latitude_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Store.latitude", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Store` table where the `longitude` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  longitude_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Store.longitude", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Store` table where the `name` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  name_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Store.name", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Store` table where the `openingHours` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  openingHours_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Store.openingHours", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Store` table where the `ownerId` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  ownerId_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Store.ownerId", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Store` table where the `phoneNumber` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  phoneNumber_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Store.phoneNumber", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `Store` table where the `website` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  website_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "Store.website", purpose: QUERY_COUNT)
  """
  ✨ Sum the `latitude` field in the `Store` table.
  """
  latitude_sum(
    """
    Set to true to sum the distinct values.
    """
    distinct: Boolean = false
  ): Float @fdc_generated(from: "Store.latitude", purpose: QUERY_SUM)
  """
  ✨ Sum the `longitude` field in the `Store` table.
  """
  longitude_sum(
    """
    Set to true to sum the distinct values.
    """
    distinct: Boolean = false
  ): Float @fdc_generated(from: "Store.longitude", purpose: QUERY_SUM)
  """
  ✨ Average the `latitude` field in the `Store` table.
  """
  latitude_avg(
    """
    Set to true to average the distinct values.
    """
    distinct: Boolean = false
  ): Float @fdc_generated(from: "Store.latitude", purpose: QUERY_AVG)
  """
  ✨ Average the `longitude` field in the `Store` table.
  """
  longitude_avg(
    """
    Set to true to average the distinct values.
    """
    distinct: Boolean = false
  ): Float @fdc_generated(from: "Store.longitude", purpose: QUERY_AVG)
  """
  ✨ Minimum of the `createdAt` field in the `Store` table.
  """
  createdAt_min: Timestamp @fdc_generated(from: "Store.createdAt", purpose: QUERY_MIN)
  """
  ✨ Minimum of the `latitude` field in the `Store` table.
  """
  latitude_min: Float @fdc_generated(from: "Store.latitude", purpose: QUERY_MIN)
  """
  ✨ Minimum of the `longitude` field in the `Store` table.
  """
  longitude_min: Float @fdc_generated(from: "Store.longitude", purpose: QUERY_MIN)
  """
  ✨ Maximum of the `createdAt` field in the `Store` table.
  """
  createdAt_max: Timestamp @fdc_generated(from: "Store.createdAt", purpose: QUERY_MAX)
  """
  ✨ Maximum of the `latitude` field in the `Store` table.
  """
  latitude_max: Float @fdc_generated(from: "Store.latitude", purpose: QUERY_MAX)
  """
  ✨ Maximum of the `longitude` field in the `Store` table.
  """
  longitude_max: Float @fdc_generated(from: "Store.longitude", purpose: QUERY_MAX)
}
extend type StoreProduct {
  """
  Implicit metadata field that cannot be written. It provides extra information about query results.
  """
  _metadata: _Metadata @fdc_generated(from: "StoreProduct", purpose: METADATA_FIELD)
  """
  ✨ Count the number of rows in the `StoreProduct` table.
  """
  _count: Int! @fdc_generated(from: "StoreProduct.", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `StoreProduct` table where the `isOnSale` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  isOnSale_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "StoreProduct.isOnSale", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `StoreProduct` table where the `price` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  price_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "StoreProduct.price", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `StoreProduct` table where the `productId` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  productId_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "StoreProduct.productId", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `StoreProduct` table where the `quantity` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  quantity_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "StoreProduct.quantity", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `StoreProduct` table where the `salePrice` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  salePrice_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "StoreProduct.salePrice", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `StoreProduct` table where the `sku` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  sku_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "StoreProduct.sku", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `StoreProduct` table where the `storeId` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  storeId_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "StoreProduct.storeId", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `StoreProduct` table where the `updatedAt` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  updatedAt_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "StoreProduct.updatedAt", purpose: QUERY_COUNT)
  """
  ✨ Sum the `price` field in the `StoreProduct` table.
  """
  price_sum(
    """
    Set to true to sum the distinct values.
    """
    distinct: Boolean = false
  ): Float @fdc_generated(from: "StoreProduct.price", purpose: QUERY_SUM)
  """
  ✨ Sum the `quantity` field in the `StoreProduct` table.
  """
  quantity_sum(
    """
    Set to true to sum the distinct values.
    """
    distinct: Boolean = false
  ): Int @fdc_generated(from: "StoreProduct.quantity", purpose: QUERY_SUM)
  """
  ✨ Sum the `salePrice` field in the `StoreProduct` table.
  """
  salePrice_sum(
    """
    Set to true to sum the distinct values.
    """
    distinct: Boolean = false
  ): Float @fdc_generated(from: "StoreProduct.salePrice", purpose: QUERY_SUM)
  """
  ✨ Average the `price` field in the `StoreProduct` table.
  """
  price_avg(
    """
    Set to true to average the distinct values.
    """
    distinct: Boolean = false
  ): Float @fdc_generated(from: "StoreProduct.price", purpose: QUERY_AVG)
  """
  ✨ Average the `quantity` field in the `StoreProduct` table.
  """
  quantity_avg(
    """
    Set to true to average the distinct values.
    """
    distinct: Boolean = false
  ): Float @fdc_generated(from: "StoreProduct.quantity", purpose: QUERY_AVG)
  """
  ✨ Average the `salePrice` field in the `StoreProduct` table.
  """
  salePrice_avg(
    """
    Set to true to average the distinct values.
    """
    distinct: Boolean = false
  ): Float @fdc_generated(from: "StoreProduct.salePrice", purpose: QUERY_AVG)
  """
  ✨ Minimum of the `price` field in the `StoreProduct` table.
  """
  price_min: Float @fdc_generated(from: "StoreProduct.price", purpose: QUERY_MIN)
  """
  ✨ Minimum of the `quantity` field in the `StoreProduct` table.
  """
  quantity_min: Int @fdc_generated(from: "StoreProduct.quantity", purpose: QUERY_MIN)
  """
  ✨ Minimum of the `salePrice` field in the `StoreProduct` table.
  """
  salePrice_min: Float @fdc_generated(from: "StoreProduct.salePrice", purpose: QUERY_MIN)
  """
  ✨ Minimum of the `updatedAt` field in the `StoreProduct` table.
  """
  updatedAt_min: Timestamp @fdc_generated(from: "StoreProduct.updatedAt", purpose: QUERY_MIN)
  """
  ✨ Maximum of the `price` field in the `StoreProduct` table.
  """
  price_max: Float @fdc_generated(from: "StoreProduct.price", purpose: QUERY_MAX)
  """
  ✨ Maximum of the `quantity` field in the `StoreProduct` table.
  """
  quantity_max: Int @fdc_generated(from: "StoreProduct.quantity", purpose: QUERY_MAX)
  """
  ✨ Maximum of the `salePrice` field in the `StoreProduct` table.
  """
  salePrice_max: Float @fdc_generated(from: "StoreProduct.salePrice", purpose: QUERY_MAX)
  """
  ✨ Maximum of the `updatedAt` field in the `StoreProduct` table.
  """
  updatedAt_max: Timestamp @fdc_generated(from: "StoreProduct.updatedAt", purpose: QUERY_MAX)
}
extend type User {
  """
  ✨ List `SearchHistory` objects in a one-to-many relationship (where `SearchHistory`.`user` is this object).
  """
  searchHistories_on_user(
    """
    Filter condition to narrow down the query results.
    """
    where: SearchHistory_Filter

    """
    Order the query results by specific fields.
    """
    orderBy: [SearchHistory_Order!]

    """
    Number of rows to skip before starting to return the results.
    """
    offset: Int

    """
    Maximum number of rows to return (defaults to 100 rows).
    """
    limit: Int = 100

    """
    Set to true to return distinct results.
    """
    distinct: Boolean = false

    """
    Filter condition to apply to the groups of aggregate queries.
    """
    having: SearchHistory_Having
  ): [SearchHistory!]! @fdc_generated(from: "SearchHistory.user", purpose: QUERY_MULTIPLE_ONE_TO_MANY)
  """
  ✨ List `Store` objects in a one-to-many relationship (where `Store`.`owner` is this object).
  """
  stores_on_owner(
    """
    Filter condition to narrow down the query results.
    """
    where: Store_Filter

    """
    Order the query results by specific fields.
    """
    orderBy: [Store_Order!]

    """
    Number of rows to skip before starting to return the results.
    """
    offset: Int

    """
    Maximum number of rows to return (defaults to 100 rows).
    """
    limit: Int = 100

    """
    Set to true to return distinct results.
    """
    distinct: Boolean = false

    """
    Filter condition to apply to the groups of aggregate queries.
    """
    having: Store_Having
  ): [Store!]! @fdc_generated(from: "Store.owner", purpose: QUERY_MULTIPLE_ONE_TO_MANY)
  """
  Implicit metadata field that cannot be written. It provides extra information about query results.
  """
  _metadata: _Metadata @fdc_generated(from: "User", purpose: METADATA_FIELD)
  """
  ✨ Count the number of rows in the `User` table.
  """
  _count: Int! @fdc_generated(from: "User.", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `User` table where the `createdAt` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  createdAt_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "User.createdAt", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `User` table where the `displayName` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  displayName_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "User.displayName", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `User` table where the `email` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  email_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "User.email", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `User` table where the `id` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  id_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "User.id", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `User` table where the `photoUrl` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  photoUrl_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "User.photoUrl", purpose: QUERY_COUNT)
  """
  ✨ Count the number of rows in the `User` table where the `uid` field is non-null. Pass the `distinct` argument to instead count the number of distinct values.
  """
  uid_count(
    """
    Set to true to count the number of distinct values.
    """
    distinct: Boolean = false
  ): Int! @fdc_generated(from: "User.uid", purpose: QUERY_COUNT)
  """
  ✨ Minimum of the `createdAt` field in the `User` table.
  """
  createdAt_min: Timestamp @fdc_generated(from: "User.createdAt", purpose: QUERY_MIN)
  """
  ✨ Maximum of the `createdAt` field in the `User` table.
  """
  createdAt_max: Timestamp @fdc_generated(from: "User.createdAt", purpose: QUERY_MAX)
}
